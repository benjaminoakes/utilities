#!/usr/bin/env ruby
# Author: Benjamin Oakes <hello@benjaminoakes.com>

require 'csv'
require 'fileutils'
require 'yaml'

def show_usage
  # or something like this?
  # __options:
  #   unique: true
  #   output_style: SAS

  STDERR.puts <<EOF
Usage: #{$PROGRAM_NAME} [--debug] [--help] [--output-style=XYZ] [--unique] csv_file rule_file

Transform a CSV file based on rules.

  --debug                 Turn on debugging information (and discard the output).
  --help                  Show this help text.
  --output-style=XYZ      Adjust the CSV output for certain programs.
                          Supported values:  SAS, Excel-2003.
  --unique                Remove duplicate output rows.
  csv_file                Input CSV file.
  rule_file               Rule file defining output.

Rule file format
----------------

The rule file is a YAML-based format.  Example:

    DEFAULTS: &DEFAULTS
      - first name
      - last name
    my_first_output_file:
      - *DEFAULTS                    # Include the columns defined as DEFAULTS (first and last name)
      - first_column                 # Only this specific column
      - AB_*                         # All columns beginning with AB_
      - /^a regular expression$/     # All columns matching this PCRE
    my_second_output_file:
      - *DEFAULTS
      - AB_*
      - CD_*                         # All columns beginning with CD_
EOF
  exit -1
end

def process_rules(rules)
  processed_rules = rules

  # Drop all capital keys (assumed to be groups)
  processed_rules.delete_if { |key, value| key.match(/^[^a-z]+$/) }

  processed_rules.keys.each do |key|
    # Not sure why, but YAML was treating the groups (e.g., DEFAULTS) as nested lists
    processed_rules[key] = processed_rules[key].flatten

    processed_rules[key].map! do |selection|
      if selection.match(/^\/(.*?)\/$/) # Regexp input syntax, e.g. /foobar/
        Regexp.new(selection[1, selection.length - 2]) # Drop the slashes -- they're just convention
      elsif selection.match(/\*/)
        # Turn globs into regexps
        Regexp.new('^' + selection.gsub('*', '.*?') + '$')
      else
        selection
      end
    end
  end

  return processed_rules
end

def matching_columns_for(header, selection_regexps)
  return selection_regexps.map { |selection_regexp| header.grep(selection_regexp) }.flatten
end

if __FILE__ == $PROGRAM_NAME
  csv_filename = nil
  rule_filename = nil
  options = {
    'output-style' => []
  }

  ARGV.each do |argument|
    case argument
    when '--debug'
      $DEBUG = true
    when '--help'
      show_usage
    when '--output-style=SAS'
      options['output-style'] << 'SAS'
    when '--output-style=Excel-2003'
      options['output-style'] << 'Excel-2003'
    # From http://office.microsoft.com/en-us/excel-help/excel-specifications-and-limits-HP005199291.aspx:
    # 
    #     Worksheet size: 65,536 rows by 256 column
    # 
    when '--unique'
      options['unique'] = true
    when /^--/
      show_usage
    else
      if csv_filename.nil?
        csv_filename = argument
      elsif rule_filename.nil?
        rule_filename = argument
      else
        show_usage
      end
    end
  end
  
  if csv_filename.nil? || rule_filename.nil?
    show_usage
  end

  output_directory = File.basename(csv_filename, '.csv')
  FileUtils.mkdir_p(output_directory) unless $DEBUG
  
  rules = YAML::load(File.open(rule_filename))
  rules = process_rules(rules)

  header = CSV.parse(File.open(csv_filename).readlines.first).flatten

  if $DEBUG
    puts "Header:"
    puts "======="
    puts
    puts header
    puts
  end

  all_column_selections = rules.map { |key, values| values }.flatten.uniq
  remainder = header - matching_columns_for(header, all_column_selections)
  missing = all_column_selections.select { |regexp| !header.any? { |column_name| regexp.match(column_name) } }

  if !missing.empty?
    STDERR.puts "ERROR: No column name matches for:"
    STDERR.puts ""
    STDERR.puts missing.map { |r| r.inspect }
    exit -1
  end

  data = CSV.parse(File.open(csv_filename).readlines.join)
  data.shift # Get rid of the header

  # We want the same timestamp for all of them
  timestamp = Time.now.strftime('date_%Y-%m-%d_time_%H-%M-%S')

  rules.each do |base_output_filename, selection_regexps|
    output_filename = File.join(output_directory, "#{base_output_filename}_#{timestamp}.csv")

    if $DEBUG
      puts
    end

    puts "Output filename: #{output_filename}"
    puts '===================================' if $DEBUG
    
    if $DEBUG
      puts
      puts "Selection Regexps:"
      puts "------------------"
      puts
      puts selection_regexps.map { |r| r.inspect }
    end

    matching_columns = matching_columns_for(header, selection_regexps)

    if $DEBUG
      puts
      puts "Matching Columns:"
      puts "-----------------"
      puts 
      puts matching_columns
    end

    unless $DEBUG
      File.open(output_filename, 'w') do |file|
        CSV::Writer.generate(file) do |csv|
          csv << matching_columns

          data.each do |row|
            matching_data = matching_columns.map { |column_name| row[header.index(column_name)] }
            csv << matching_data
          end
        end
      end
    end
  end
end

